import lemmas.canonical_forms
import lemmas.fv
import lemmas.subst
import lemmas.inversion

theorem progress
  {Γ: cx typ}
  {e: exp}
  {τ: typ}
  (fv_e: fv e = [])
  (et: has_typ Γ e τ)
  : val e ∨ (∃ (e': exp), steps e e') :=
begin
  induction et,
  left,
  exact val.int et_n,
  left,
  exact val.true,
  left,
  exact val.false,
  right,
  let emp := iff.elim_left (if_fv_empty et_e1 et_e2 et_e3) fv_e,
  cases et_ih_a emp.left,
  cases bool_canonical_forms h et_a,
  rw h_1,
  existsi et_e2,
  exact steps.if_true,
  rw h_1,
  existsi et_e3,
  exact steps.if_false,
  cases h,
  existsi exp.if_ h_w et_e2 et_e3,
  exact steps.if_e1 h_h,
  simp [fv] at fv_e,
  exfalso,
  exact fv_e,
  left,
  exact val.fn et_x et_τ1 et_e,
  let emp := iff.elim_left (app_fv_empty et_e1 et_e2) fv_e,
  cases et_ih_a emp.left,
  cases et_ih_a_1 emp.right,
  cases arrow_canonical_forms h et_a,
  cases h_2,
  right,
  existsi subst et_e2 w emp.right h_2_w,
  let d := steps.app_done emp.right h_1,
  -- avoid weird 'motive is not type correct' error
  rw symm h_2_h at d,
  exact d,
  right,
  cases h_1,
  existsi exp.app et_e1 h_1_w,
  exact steps.app_e2 h h_1_h,
  right,
  cases h,
  existsi exp.app h_w et_e2,
  exact steps.app_e1 h_h,
  left,
  exact val.unit,
  let emp := iff.elim_left (prod_fv_empty et_e1 et_e2) fv_e,
  cases et_ih_a emp.left,
  cases et_ih_a_1 emp.right,
  left,
  exact val.prod h h_1,
  cases h_1,
  right,
  existsi exp.prod et_e1 h_1_w,
  exact steps.prod_e2 h h_1_h,
  cases h,
  right,
  existsi exp.prod h_w et_e2,
  exact steps.prod_e1 h_h,
  simp [prod_left_fv] at fv_e,
  right,
  cases et_ih fv_e,
  cases prod_canonical_forms h et_a,
  cases h_1,
  rw h_1_h at h ⊢,
  existsi w,
  exact steps.prod_left_done h,
  cases h,
  existsi exp.prod_left h_w,
  exact steps.prod_left_arg h_h,
  simp [prod_right_fv] at fv_e,
  right,
  cases et_ih fv_e,
  cases prod_canonical_forms h et_a,
  cases h_1,
  rw h_1_h at h ⊢,
  existsi h_1_w,
  exact steps.prod_right_done h,
  cases h,
  existsi exp.prod_right h_w,
  exact steps.prod_right_arg h_h,
end

theorem preservation
  {Γ: cx typ}
  {e e': exp}
  {τ: typ}
  (fv_e: fv e = [])
  (et: has_typ Γ e τ)
  (st: steps e e')
  : has_typ Γ e' τ ∧ fv e' = [] :=
begin
  induction st generalizing Γ τ,
  let inv := inversion_if et,
  let emp := iff.elim_left (if_fv_empty st_e1 st_e2 st_e3) fv_e,
  let e1'_ih := st_ih emp.left inv.left,
  split,
  exact has_typ.if_ e1'_ih.left inv.right.left inv.right.right,
  exact iff.elim_right (if_fv_empty st_e1' st_e2 st_e3) (and.intro e1'_ih.right emp.right),
  let inv := inversion_if et,
  let emp := iff.elim_left (if_fv_empty exp.true st_e2 st_e3) fv_e,
  exact and.intro inv.right.left emp.right.left,
  let inv := inversion_if et,
  let emp := iff.elim_left (if_fv_empty exp.false st_e2 st_e3) fv_e,
  exact and.intro inv.right.right emp.right.right,
  cases inversion_app et,
  let emp := iff.elim_left (app_fv_empty st_e1 st_e2) fv_e,
  let e1'_ih := st_ih emp.left h.left,
  split,
  exact has_typ.app e1'_ih.left h.right,
  exact iff.elim_right (app_fv_empty st_e1' st_e2) (and.intro e1'_ih.right emp.right),
  cases inversion_app et,
  let emp := iff.elim_left (app_fv_empty st_e1 st_e2) fv_e,
  let e2'_ih := st_ih emp.right h.right,
  split,
  exact has_typ.app h.left e2'_ih.left,
  exact iff.elim_right (app_fv_empty st_e1 st_e2') (and.intro emp.left e2'_ih.right),
  split,
  cases inversion_app et,
  cases inversion_fn h.left,
  let a := typ.arrow.inj h_1.left,
  rw a.left at h,
  rw a.right,
  exact subst_preservation rfl st_fv_e2 h_1.right h.right,
  rw subst_fv st_e2 st_x st_fv_e2 st_e,
  let emp := iff.elim_left (app_fv_empty (exp.fn st_x st_τ st_e) st_e2) fv_e,
  rw fn_fv st_x st_τ st_e at emp,
  exact emp.left,
  cases inversion_prod et,
  cases h,
  simp [prod_fv_empty] at fv_e,
  let a := st_ih fv_e.left h_h.right.left,
  split,
  rw h_h.left,
  exact has_typ.prod a.left h_h.right.right,
  exact iff.elim_right (prod_fv_empty st_e1' st_e2) (and.intro a.right fv_e.right),
  cases inversion_prod et,
  cases h,
  simp [prod_fv_empty] at fv_e,
  let a := st_ih fv_e.right h_h.right.right,
  split,
  rw h_h.left,
  exact has_typ.prod h_h.right.left a.left,
  exact iff.elim_right (prod_fv_empty st_e1 st_e2') (and.intro fv_e.left a.right),
  --
  cases inversion_prod_left et,
  simp [prod_left_fv] at fv_e,
  let a := st_ih fv_e h,
  split,
  exact has_typ.prod_left a.left,
  simp [prod_left_fv],
  exact a.right,
  cases inversion_prod_left et,
  cases inversion_prod h,
  cases h_1,
  let a := typ.prod.inj h_1_h.left,
  rw a.left,
  split,
  exact h_1_h.right.left,
  simp [prod_left_fv] at fv_e,
  simp [prod_fv_empty] at fv_e,
  exact fv_e.left,
  --
  cases inversion_prod_right et,
  simp [prod_right_fv] at fv_e,
  let a := st_ih fv_e h,
  split,
  exact has_typ.prod_right a.left,
  simp [prod_right_fv],
  exact a.right,
  cases inversion_prod_right et,
  cases inversion_prod h,
  cases h_1,
  let a := typ.prod.inj h_1_h.left,
  rw a.right,
  split,
  exact h_1_h.right.right,
  simp [prod_right_fv] at fv_e,
  simp [prod_fv_empty] at fv_e,
  exact fv_e.right,
end

-- the big one
theorem safety
  {Γ: cx typ}
  {e: exp}
  {τ: typ}
  (fv_e: fv e = [])
  (et: has_typ Γ e τ)
  : val e ∨ (∃ (e': exp), steps e e' ∧ has_typ Γ e' τ ∧ fv e' = []) :=
begin
  cases progress fv_e et,
  left,
  exact h,
  cases h,
  right,
  existsi h_w,
  split,
  exact h_h,
  exact preservation fv_e et h_h,
end

theorem uniqueness {Γ: cx typ} {e: exp} {τ τ': typ}:
  has_typ Γ e τ ->
  has_typ Γ e τ' ->
  τ = τ' :=
begin
  intros h1 h2,
  induction h1 generalizing τ',
  cases h2,
  refl,
  cases h2,
  refl,
  cases h2,
  refl,
  cases h2,
  exact h1_ih_a_1 h2_a_1,
  cases h2,
  exact lookup_uniq h1_a h2_a,
  cases h2,
  rw h1_ih h2_a,
  cases h2,
  exact (typ.arrow.inj (h1_ih_a h2_a)).right,
  cases h2,
  refl,
  cases h2,
  rw h1_ih_a h2_a,
  rw h1_ih_a_1 h2_a_1,
  cases h2,
  exact (typ.prod.inj (h1_ih h2_a)).left,
  cases h2,
  exact (typ.prod.inj (h1_ih h2_a)).right,
end
